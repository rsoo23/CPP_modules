access keywords: 
- public: members are accessible outside the class
- private: members cannot be accessed / viewed from outside the class
- protected: members cannot be accessed / viewed from outside the class, but can be inherited

constructors vs methods:
    constructors (initializer):
    - special member function that is automatically called when object of class is created
    - initialize the objects data + allocate resources
    - they do not have a return type

    methods:
    - have to be called explicitly
    - can have different return values

attributes

encapsulation:
- better to do as often as you can
- make sure that sensitive data is hidden from users
- if you want to modify the value of a private member, you need to use get and set methods

this:
    - used to differentiate between member variables of a class to 
      function parameters / local variables that might have the same name
    - use of this is implicit, however it improves code clarity
Ex:
void MyClass::setValue(int value) {
    this->value = value;
}

pragma once
    - marks that specific header file so that it won't be included again during the same 
    compilation process, regardless of how many times it's referenced. 

dynamic allocation
	Class* name = new Class[N] -> must have void constructor
	delete [] name

references and pointers
	- references
		- more intuitive syntax
		- safer, in terms of avoiding null-pointer issues
		- int& num; (you can directly change the value using num = .., while pointers
		need dereferencing)
	- pointers
		- more flexibility
		- can be reassigned to point to different objects

______________________________________________________________________________________________________
floating point numbers

fixed point numbers
    - straightforward and efficient (integer arithmetic)
    - loss of range for gain in precision vice versa

friend function
    - a function that is not a member of a class, but is given access to private 
    and protected members of the class

______________________________________________________________________________________________________
inheritance rules:
	- base class: private, public, protected

	- public inheritance: 
		public preserved
		protected preserved
		private preserved

	- protected inheritance: 
		public -> protected
		protected preserved
		private preserved

	- private inheritance: 
		public -> private
		protected -> private
		private preserved

multiple inheritance
	- let's say we have two base classes with both function1()
	BaseClass1: function1(), BaseClass2: function1()

	and a derived class with function1()
	DerivedClass: public BaseClass1, public BaseClass2
		- when we call derived.function1(), overriding occurs,
		  so the function1() from the derived class is executed

	if the derived class doesn't have function1()
		- when derived.function1() is called:
		- an error occurs since there is a conflict between BaseClass1 
		  BaseClass2 (same function1())

virtual destructors
	- used in base class destructor
	- ensures both base class and derived class destructors are called
	- ensure that the destructor of the most derived class is called when deleting a pointer to an object of the base class

______________________________________________________________________________________________________
subtype polymorphism (run-time polymorphism)
	- concept that allows you to treat derived classes as their base classes

abstract classes
	- classes that are meant to be subclassed
	- contains one or more pure virtual functions that must be implemented by
	  derived classes
	- cannot be instantiated
	- can also include:
		- data members
		- non-pure virtual methods

interface
	- collection of abstract methods (pure virtual functions)
	- no data members

virtual functions
	- allow the overriding of base class functions in derived classes

pure virtual functions (interface)
	- virtual void doSomething() = 0;
	- no implementation in the base class
	- a way to define an interface that must be implemented by all derived classes

shallow copy
	- copies over the variables of the original object
	- works if none of the variables is defined in the heap

	- if the data is dynamically allocated from the heap section, then the copied object
	  variable will also reference the same memory location
	- This will create ambiguity and run-time errors, dangling pointer. Since both objects
	  will reference to the same memory location, then change made by one will reflect those
	  change in another object as well. Since we wanted to create a replica of the object,
	  this purpose will not be filled by Shallow copy

deep copy
	- In Deep copy, an object is created by copying data of all variables, and it also allocates
	  similar memory resources with the same value to the object. In order to perform Deep copy,
	  we need to explicitly define the copy constructor and assign dynamic memory as well, if required.
	  Also, it is required to dynamically allocate memory to the variables in the other constructors,
	  as well

______________________________________________________________________________________________________

Casting:
	1. c-style cast
	explicit casts:
	2. reintepret cast
	3. dynamic cast
	4. static cast
	5. const cast
Use of C style casting is discouraged due its many pitfalls. Instead, explicit casts are used for better
type safety and more readable and maintable code.

1. C-style casting
	- allows conversion between fundamental data types, user-defined types and pointer types
	Cons:
		- lacks type safety: leads to unexpected results, undefined behaviour, doesn't perform
		runtime checks to ensure the conversion is valid
		- implicit conversions: conversions between types that are not related to each other (ex. pointer to int)
		- combining multiple casts: can perform const cast and reintepret cast
		- hard to spot

2. reintepret cast
	int value = 42;
	char *ptr = reintepret_cast<char *>(&value)

	- most dangerous
	- unsafe type conversion:
		can perform conversions between unrelated pointer types and pointer to intergral types
	- bit level conversion:
		doesn't ensure the conversion is valid,
	- no type checking
	- potential undefined behaviour
	- should be avoided as much as possible

3. dynamic cast
	- used for polymorphic types: 
		handles conversions within an inheritance hierarchy of polymorphic classes
		(a class is considered polymorphic if it has at least one virtual function)
	- downcasting safety:
		converts base class pointers / reference to a derived class pointer / reference safely
	- runtime type checking:
		ensures conversion is valid, if not it returns a nullptr / throws std::bad_cast exception
	  	for references
	- upcasting
		reverse of downcasting
		not recommended since static_cast can perform them safely and is more efficient
	- use with polymorphism:
		relies on the presence of virtual functions in the class hierarchy to work correctly
		it uses the virtual table (vtable) to determine the actual type of the object at runtime

4. static cast
	- numeric casting:
		allows safe and well-defined conversions between types like int, float, double
	- pointer and reference conversion:
		allows upcasting, downcasting and conversions between pointers to related types
	- no runtime checking
		relies on programmers knowledge on whether if its safe
		validity of the conversion is checked in compile time
	- downcasting limitations:
		should only be used if you are sure that the derived class object is that of the target type
		use dynamic_cast if you are not sure
	- user-defined conversions

5. const cast
	used to add / remove the const-ness of a variable
	- safety considerations:
		removing const-ness and changing a variable might lead to undefined behaviour
	- adding const-ness:
		useful when you want to pass a non-const variable into a function that takes in a const
		reference / pointer
	- can be used for pointer and reference types
	- only use it for its purpose and nothing else
	- it is the safest since it doesn't change any values

static class
- no direct equivalent of static class like in Java, but we can simulate it:
	1. only static members
	2. cannot be instantiated to create objects
	3. namespace-like organization (serves as a container for grouping related static members)
	4. optional constructor / destructor (place them in private if defined)

______________________________________________________________________________________________________

function templates
class templates

iterators:
purpose:
	- abstraction: 
		hides the details of how the container is implemented, allows generic algs that works with different
		containers without needing to know the internal structure
	- uniform interface: 
		provides a generic way to traverse through the container, makes it easier to write generic algs that 
		work with any container that support iterators
	- compatibility:
		allows standard algs to be applied to different types of containers, since iterators standardise the 
		iteration of elements
	- different types of iterators:
		example below

1. input
	- supports reading values from a sequence
	- single pass traversal
	- ex: std::vector<int>::iterator it = numbers.begin()

2. output
	- supports writing values to a sequence
	- single pass traversal	
	- ex: std::vector<int>::iterator it = std::back_inserter(outputNumbers)
	  (where outputNumbers is a vector<int>)

3. forward
	- contain all features in prev two
	- can only move forward (incrementing)
	- ex: std::forward_list<int>::iterator it = numbers.begin()
	      it++

4. bidirectional
	- contain all features in forward iterators
	- can move in both directions (incrementing and decrementing)
	- ex: std::list<int>::iterator it = numbers.begin()
	      it++, it--

5. random access
	- can randomly access any element inside the container
	- behaves like a pointer
	- pointer aritmethic operations
	- ex: std::vector<int>::iterator it = numbers.begin()
	      *it, *(it + 2), it++, it--

containers:
1. sequence
	- implement data structures that are accessed sequentially
	- array, vector, deque, forward_list, list

2. associative
	- implement sorted data structures that can be quickly searched
	  with (Ologn complexity)
	- set, map, multiset, multimap

3. unordered associative
	- implement unsorted (hashed) data structures that can be quickly searched 
	(O(1) amortized, O(n) worst-case complexity)
	- unordered ~ (same as associative)

4. container adapters
	- provide a different interface for sequential containers
	- stack, queue, priority_queue

______________________________________________________________________________________________________

sorts:
	merge: break into halves recursively, join and sort
	insertion: swap until sorted
	selection: find minimum, then swap
	quick: pivoting
